<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Rocket! ðŸš€</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;touch-action:none;-webkit-user-select:none;user-select:none;background:#080822}
canvas{display:block;width:100%;height:100%}
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H, BU;
function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  BU = Math.min(W, H) / 500;
  if (BU < 0.7) BU = 0.7;
}
resize();
window.addEventListener('resize', resize);

// Audio â€” realistic rocket engine
const AC = new (window.AudioContext || window.webkitAudioContext)();

// Create noise buffer for engine rumble
const noiseBuf = AC.createBuffer(1, AC.sampleRate * 2, AC.sampleRate);
const noiseData = noiseBuf.getChannelData(0);
for (let i = 0; i < noiseData.length; i++) noiseData[i] = Math.random() * 2 - 1;

// Engine sound graph (always running, gain-controlled)
const noiseNode = AC.createBufferSource();
noiseNode.buffer = noiseBuf;
noiseNode.loop = true;

// Low rumble filter
const lpf = AC.createBiquadFilter();
lpf.type = 'lowpass';
lpf.frequency.value = 280;
lpf.Q.value = 2.5;

// Mid crackle filter
const bpf = AC.createBiquadFilter();
bpf.type = 'bandpass';
bpf.frequency.value = 900;
bpf.Q.value = 1.2;

// Sub bass oscillator for deep thrust feel
const subOsc = AC.createOscillator();
subOsc.type = 'sawtooth';
subOsc.frequency.value = 55;

// Tremolo LFO for engine texture
const lfo = AC.createOscillator();
lfo.type = 'triangle';
lfo.frequency.value = 18;
const lfoGain = AC.createGain();
lfoGain.gain.value = 0.3;

// Gain nodes
const noiseGainLP = AC.createGain();
const noiseGainBP = AC.createGain();
const subGain = AC.createGain();
const masterGain = AC.createGain();

noiseGainLP.gain.value = 0;
noiseGainBP.gain.value = 0;
subGain.gain.value = 0;
masterGain.gain.value = 0.45;

// Wire up: noise â†’ lowpass â†’ gain, noise â†’ bandpass â†’ gain, sub osc â†’ gain
noiseNode.connect(lpf);
lpf.connect(noiseGainLP);

const noiseMid = AC.createBufferSource();
noiseMid.buffer = noiseBuf;
noiseMid.loop = true;
noiseMid.connect(bpf);
bpf.connect(noiseGainBP);

subOsc.connect(subGain);

// LFO modulates master gain for texture
lfo.connect(lfoGain);
lfoGain.connect(masterGain.gain);

// Mix to master
noiseGainLP.connect(masterGain);
noiseGainBP.connect(masterGain);
subGain.connect(masterGain);
masterGain.connect(AC.destination);

// Start all sources (they run forever, volume-controlled)
let engineStarted = false;
function ensureEngine() {
  if (engineStarted) return;
  engineStarted = true;
  noiseNode.start();
  noiseMid.start();
  subOsc.start();
  lfo.start();
}

// Target gain for smooth ramping
let engineTarget = 0;
const ATTACK = 0.06;   // seconds to ramp up
const RELEASE = 0.25;  // seconds to fade out

function engineOn() {
  if (AC.state === 'suspended') AC.resume();
  ensureEngine();
  engineTarget = 1;
  const t = AC.currentTime;
  noiseGainLP.gain.cancelScheduledValues(t);
  noiseGainBP.gain.cancelScheduledValues(t);
  subGain.gain.cancelScheduledValues(t);
  noiseGainLP.gain.setTargetAtTime(0.55, t, ATTACK);
  noiseGainBP.gain.setTargetAtTime(0.25, t, ATTACK);
  subGain.gain.setTargetAtTime(0.18, t, ATTACK);
  lpf.frequency.setTargetAtTime(320, t, ATTACK);
}

function engineOff() {
  engineTarget = 0;
  const t = AC.currentTime;
  noiseGainLP.gain.cancelScheduledValues(t);
  noiseGainBP.gain.cancelScheduledValues(t);
  subGain.gain.cancelScheduledValues(t);
  noiseGainLP.gain.setTargetAtTime(0, t, RELEASE);
  noiseGainBP.gain.setTargetAtTime(0, t, RELEASE);
  subGain.gain.setTargetAtTime(0, t, RELEASE);
  lpf.frequency.setTargetAtTime(180, t, RELEASE);
}

// Impulse punch â€” short burst layered on top for tap responsiveness
function enginePunch() {
  if (AC.state === 'suspended') AC.resume();
  ensureEngine();
  const t = AC.currentTime;
  // Snap gains high immediately for punch
  noiseGainLP.gain.cancelScheduledValues(t);
  noiseGainBP.gain.cancelScheduledValues(t);
  subGain.gain.cancelScheduledValues(t);
  noiseGainLP.gain.setValueAtTime(0.7, t);
  noiseGainBP.gain.setValueAtTime(0.35, t);
  subGain.gain.setValueAtTime(0.25, t);
  lpf.frequency.setValueAtTime(450, t);
  // Quick burst: high-frequency crackle
  lpf.frequency.setTargetAtTime(320, t + 0.05, 0.08);
  // Sub thump
  subOsc.frequency.setValueAtTime(80, t);
  subOsc.frequency.setTargetAtTime(55, t + 0.04, 0.06);
}

// Stars
const stars = [];
for (let i = 0; i < 90; i++) {
  stars.push({
    x: Math.random() * 3000, y: Math.random() * 3000,
    r: Math.random() * 2 + 0.5,
    tw: Math.random() * 6.28, sp: Math.random() * 0.02 + 0.01,
    par: Math.random() * 0.3 + 0.1
  });
}

// 10 bodies â€” each at a fixed height in the world
const bodies = [
  {name:'Moon',    c:'#ddddaa', r:18},
  {name:'Mars',    c:'#cc4422', r:24},
  {name:'Jupiter', c:'#dd9944', r:48},
  {name:'Saturn',  c:'#ddbb66', r:36, rings:true},
  {name:'Neptune', c:'#4466cc', r:28},
  {name:'Mercury', c:'#aaaaaa', r:16},
  {name:'Venus',   c:'#eecc66', r:22},
  {name:'Uranus',  c:'#77cccc', r:30},
  {name:'Pluto',   c:'#bbaa88', r:11},
  {name:'Sun',     c:'#ffdd44', r:52, glow:true},
];

// Rocket (moves on screen same as original)
let rocketY, rocketVY, boosting = false, boostTimer = 0;
rocketY = H * 0.55;
rocketVY = 0;

// World altitude â€” fire pushes up, gravity pulls back to Earth
let altitude = 0;

// Particles
const particles = [];
function spawnFlame(x, y) {
  if (particles.length > 100) return;
  for (let i = 0; i < 4; i++) {
    particles.push({
      x: x + (Math.random()-0.5)*12*BU, y,
      vx: (Math.random()-0.5)*2, vy: Math.random()*4+2,
      life: 1, size: (Math.random()*6+3)*BU,
      color: Math.random()>0.5 ? '#ff6600' : '#ffcc00'
    });
  }
}

// Input
let holding = false;
function boost() {
  boosting = true;
  boostTimer = 8;
  rocketVY = Math.max(rocketVY - 2.5, -4.5);
  enginePunch();
  engineOn();
}
function holdStart(e) { e.preventDefault(); holding = true; boost(); }
function holdEnd(e) { holding = false; engineOff(); }
window.addEventListener('keydown', e => { e.preventDefault(); boost(); });
window.addEventListener('keyup', () => { if (!holding) engineOff(); });
canvas.addEventListener('mousedown', holdStart);
canvas.addEventListener('mouseup', holdEnd);
canvas.addEventListener('mouseleave', holdEnd);
canvas.addEventListener('touchstart', holdStart, {passive:false});
canvas.addEventListener('touchend', holdEnd);
canvas.addEventListener('touchcancel', holdEnd);

// World-to-screen: rocket at H*0.45, world scrolls around it
function wts(worldY) {
  return H * 0.6 - (worldY - altitude);
}

// Draw rocket (same as original)
function drawRocket(x, y, sc, tilt) {
  ctx.save();
  ctx.translate(x, y); ctx.rotate(tilt); ctx.scale(sc, sc);
  ctx.beginPath();
  ctx.moveTo(0,-50); ctx.bezierCurveTo(-15,-35,-18,10,-18,30);
  ctx.lineTo(18,30); ctx.bezierCurveTo(18,10,15,-35,0,-50); ctx.closePath();
  const bg = ctx.createLinearGradient(-18,-50,18,30);
  bg.addColorStop(0,'#fff'); bg.addColorStop(0.5,'#e8e8e8'); bg.addColorStop(1,'#ccc');
  ctx.fillStyle = bg; ctx.fill();
  ctx.strokeStyle = '#999'; ctx.lineWidth = 1.5; ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(0,-50); ctx.bezierCurveTo(-8,-42,-12,-30,-14,-22);
  ctx.lineTo(14,-22); ctx.bezierCurveTo(12,-30,8,-42,0,-50);
  ctx.closePath(); ctx.fillStyle = '#ff3344'; ctx.fill();
  ctx.beginPath(); ctx.arc(0,-5,9,0,6.28);
  ctx.fillStyle = '#55ccff'; ctx.fill();
  ctx.beginPath(); ctx.arc(-2,-7,4,0,6.28);
  ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.fill();
  ctx.fillStyle = '#ff3344';
  ctx.beginPath(); ctx.moveTo(-18,20); ctx.lineTo(-32,38); ctx.lineTo(-18,30); ctx.fill();
  ctx.beginPath(); ctx.moveTo(18,20); ctx.lineTo(32,38); ctx.lineTo(18,30); ctx.fill();
  ctx.beginPath(); ctx.moveTo(-16,10); ctx.lineTo(16,10); ctx.lineTo(17,16); ctx.lineTo(-17,16);
  ctx.closePath(); ctx.fillStyle = '#ff6600'; ctx.fill();
  ctx.restore();
}

function lighten(hex, n) {
  let r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
  return `rgb(${Math.min(255,r+n)},${Math.min(255,g+n)},${Math.min(255,b+n)})`;
}

// Main loop
let lastTime = 0, frameCount = 0;

function update(time) {
  const dt = Math.min((time - lastTime) / 16.67, 3);
  lastTime = time;
  frameCount++;

  const SPACING = Math.max(350, H * 1.1);
  const MAX_ALT = 10.5 * SPACING;

  // Hold-to-fire: keep boosting while touch/mouse is held
  if (holding) {
    boosting = true;
    boostTimer = 4;
    rocketVY = Math.max(rocketVY - 0.35 * dt, -4.5);
  }

  // Turn off engine sound when boost ends naturally (keyboard taps)
  if (!boosting && !holding && engineTarget === 1) engineOff();

  // Rocket on-screen physics
  if (boostTimer > 0) {
    boostTimer -= dt;
    rocketVY -= 0.1 * dt;
    spawnFlame(W/2, rocketY + 30*BU);
  } else boosting = false;

  rocketVY += 0.22 * dt;
  rocketVY *= (rocketVY > 0) ? 0.993 : 0.985;
  rocketVY = Math.max(-4.5, Math.min(rocketVY, 4.5));

  // Progressive edge transfer â€” near edges, velocity smoothly
  // shifts from screen movement into world scroll (no walls)
  const pad = 120 * BU;                // rocket height + generous margin
  const limitTop = pad;                 // rocket center never above this
  const limitBot = H - pad;             // rocket center never below this
  const edgeTop = limitTop + H * 0.18;  // transfer fades in over 18% of screen
  const edgeBot = limitBot - H * 0.18;
  let transfer = 0;
  if (rocketVY < 0 && rocketY < edgeTop) {
    const t = (edgeTop - rocketY) / (edgeTop - limitTop);
    transfer = Math.min(1, t * t);
  } else if (rocketVY > 0 && rocketY > edgeBot) {
    const t = (rocketY - edgeBot) / (limitBot - edgeBot);
    transfer = Math.min(1, t * t);
  }
  rocketY += rocketVY * (1 - transfer * 0.95) * dt;
  altitude -= rocketVY * transfer * 0.9 * dt;
  rocketY = Math.max(limitTop, Math.min(rocketY, limitBot));

  // Base world scroll
  if (boosting) altitude += 2.5 * dt;
  altitude -= 0.25 * dt;
  if (altitude < 0) altitude = 0;
  if (altitude > MAX_ALT) altitude = MAX_ALT;

  // === DRAW ===
  ctx.fillStyle = '#080822';
  ctx.fillRect(0, 0, W, H);

  // Stars (parallax with altitude)
  for (const s of stars) {
    s.tw += s.sp;
    const a = 0.3 + Math.sin(s.tw) * 0.35;
    const sx = s.x % W;
    const sy = ((s.y + altitude * s.par) % H + H) % H;
    ctx.beginPath(); ctx.arc(sx, sy, s.r, 0, 6.28);
    ctx.fillStyle = `rgba(255,255,240,${a})`; ctx.fill();
  }

  // Earth (big curved surface at world height 0)
  const earthSY = wts(0);
  if (earthSY < H + 50) {
    const eR = W * 3;
    // Atmosphere glow
    ctx.beginPath(); ctx.arc(W/2, earthSY + eR, eR + 6, 0, 6.28);
    ctx.strokeStyle = 'rgba(100,180,255,0.3)'; ctx.lineWidth = 6; ctx.stroke();
    // Earth body
    ctx.beginPath(); ctx.arc(W/2, earthSY + eR, eR, 0, 6.28);
    const eg = ctx.createRadialGradient(W/2 - eR*0.2, earthSY + eR*0.3, eR*0.1, W/2, earthSY + eR, eR);
    eg.addColorStop(0, '#4488dd');
    eg.addColorStop(0.3, '#33aa55');
    eg.addColorStop(0.6, '#2288cc');
    eg.addColorStop(1, '#0a2244');
    ctx.fillStyle = eg; ctx.fill();
    // "Earth" label
    if (earthSY > H * 0.5) {
      ctx.font = `bold ${Math.max(14, 20*BU)}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      ctx.fillText('Earth', W/2, earthSY - 8*BU);
    }
  }

  // Big background numbers â€” centered, transparent, Star Trek credits style
  const bigNumF = Math.max(200, Math.min(520, W * 0.7));
  const bigNameF = Math.max(40, Math.min(100, W * 0.14));

  for (let i = 0; i < 10; i++) {
    const wy = (i + 1) * SPACING;
    const sy = wts(wy);
    if (sy < -200 || sy > H + 200) continue;
    // Number
    ctx.font = `bold ${bigNumF}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(255,255,255,0.07)';
    ctx.fillText(String(i + 1), W / 2, sy + bigNumF * 0.35);
    // Planet name
    ctx.font = `bold ${bigNameF}px sans-serif`;
    ctx.fillStyle = 'rgba(255,255,255,0.09)';
    ctx.fillText(bodies[i].name, W / 2, sy + bigNumF * 0.35 + bigNameF * 1.2);
  }

  // 10 planets at fixed world heights
  const nameF = Math.max(14, Math.min(28, W * 0.045));

  for (let i = 0; i < 10; i++) {
    const wy = (i + 1) * SPACING;
    const sy = wts(wy);
    if (sy < -100 || sy > H + 100) continue;

    const px = (i % 2 === 0) ? W * 0.22 : W * 0.78;
    const b = bodies[i];
    const r = b.r * BU;

    // Sun glow
    if (b.glow) {
      const gg = ctx.createRadialGradient(px, sy, r*0.5, px, sy, r*2.5);
      gg.addColorStop(0, 'rgba(255,220,60,0.35)');
      gg.addColorStop(1, 'rgba(255,220,60,0)');
      ctx.fillStyle = gg;
      ctx.fillRect(px-r*2.5, sy-r*2.5, r*5, r*5);
    }

    // Planet body
    ctx.beginPath(); ctx.arc(px, sy, r, 0, 6.28);
    const pg = ctx.createRadialGradient(px-r*0.3, sy-r*0.3, r*0.1, px, sy, r);
    pg.addColorStop(0, lighten(b.c, 50)); pg.addColorStop(1, b.c);
    ctx.fillStyle = pg; ctx.fill();

    // Saturn rings
    if (b.rings) {
      ctx.beginPath(); ctx.ellipse(px, sy, r*2, r*0.4, -0.25, 0, 6.28);
      ctx.strokeStyle = '#ccbb77'; ctx.lineWidth = r*0.22; ctx.stroke();
    }
    // Jupiter bands
    if (b.name === 'Jupiter') {
      ctx.save(); ctx.beginPath(); ctx.arc(px, sy, r, 0, 6.28); ctx.clip();
      ['#dd9944','#cc8833','#eebb55','#dd9944','#bb7733'].forEach((c,j) => {
        ctx.fillStyle = c;
        ctx.fillRect(px-r, sy-r+j*(2*r/5), 2*r, 2*r/5);
      });
      ctx.beginPath(); ctx.ellipse(px+r*0.3, sy+r*0.15, r*0.2, r*0.12, 0.2, 0, 6.28);
      ctx.fillStyle = '#cc4433'; ctx.fill();
      ctx.restore();
    }
    // Moon craters
    if (b.name === 'Moon') {
      ctx.beginPath(); ctx.arc(px-r*0.3, sy-r*0.2, r*0.17, 0, 6.28);
      ctx.fillStyle = 'rgba(150,150,120,0.4)'; ctx.fill();
      ctx.beginPath(); ctx.arc(px+r*0.2, sy+r*0.3, r*0.2, 0, 6.28);
      ctx.fillStyle = 'rgba(150,150,120,0.35)'; ctx.fill();
    }
    // Mars ice cap
    if (b.name === 'Mars') {
      ctx.beginPath(); ctx.arc(px, sy-r*0.65, r*0.35, 0, 6.28);
      ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.fill();
    }

    // Name (below planet)
    ctx.font = `bold ${nameF}px sans-serif`;
    ctx.fillStyle = b.c;
    ctx.fillText(b.name, px, sy + r + nameF + 4*BU);
  }

  // Particles
  for (let i = particles.length-1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx*dt; p.y += p.vy*dt;
    p.life -= 0.04*dt;
    if (p.life <= 0) { particles.splice(i,1); continue; }
    ctx.globalAlpha = p.life;
    ctx.beginPath(); ctx.arc(p.x, p.y, p.size*p.life, 0, 6.28);
    ctx.fillStyle = p.color; ctx.fill();
    ctx.globalAlpha = 1;
  }

  // Rocket
  const wobble = Math.sin(frameCount*0.03)*0.05 + rocketVY*0.015;
  if (boosting) {
    ctx.save(); ctx.shadowColor = '#ff8800'; ctx.shadowBlur = 25*BU;
    drawRocket(W/2, rocketY, BU, wobble);
    ctx.restore();
  } else {
    drawRocket(W/2, rocketY, BU, wobble);
  }

  // Hint
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.font = `${Math.max(12, 14*BU)}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.fillText('ontouchstart' in window ? 'Tap!' : 'Press any key or click!', W/2, H - 14);

  requestAnimationFrame(update);
}

requestAnimationFrame(update);
</script>
</body>
</html>
