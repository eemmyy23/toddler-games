<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Rocket! ðŸš€</title>
<link rel="icon" href="icon-192.png" type="image/png">
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#080822">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="apple-touch-icon" href="icon-192.png">
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;touch-action:none;-webkit-user-select:none;user-select:none;background:#080822}
canvas{display:block;width:100%;height:100%}
#install-bar{position:fixed;top:0;left:0;right:0;z-index:10;display:none;align-items:center;justify-content:center;gap:12px;padding:10px 16px;background:rgba(20,20,60,0.92);backdrop-filter:blur(8px);border-bottom:1px solid rgba(255,255,255,0.1);font-family:system-ui,sans-serif}
#install-bar button{border:none;border-radius:8px;padding:8px 18px;font-size:15px;font-weight:600;cursor:pointer;touch-action:manipulation}
#install-btn{background:#ff5533;color:#fff}
#install-btn:active{background:#dd3311}
#dismiss-btn{background:transparent;color:rgba(255,255,255,0.5);font-size:20px;padding:4px 10px;line-height:1}
#install-msg{color:#eee;font-size:14px}
</style>
</head>
<body>
<div id="install-bar">
  <span id="install-msg"></span>
  <button id="install-btn">Install App</button>
  <button id="dismiss-btn">&times;</button>
</div>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H, BU;
function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  BU = Math.min(W, H) / 500;
  if (BU < 0.7) BU = 0.7;
}
resize();
window.addEventListener('resize', resize);

// Audio â€” warm rocket whoosh engine (created on first user gesture)
let AC = null;
let engineReady = false;
let whooshGain, hissGain, subGain, masterGain;
let whooshFilter, hissFilter, hpf;
let subOsc;
let engineTarget = 0;

function buildEngine() {
  if (engineReady) return;
  if (!AC) AC = new (window.AudioContext || window.webkitAudioContext)();
  engineReady = true;

  // Noise buffer (2 sec loop)
  const buf = AC.createBuffer(2, AC.sampleRate * 2, AC.sampleRate);
  // Channel 0: brownish noise (warmer, less harsh than white)
  const d0 = buf.getChannelData(0);
  let b0 = 0;
  for (let i = 0; i < d0.length; i++) {
    b0 = (b0 + (Math.random() * 2 - 1) * 0.06) * 0.98;
    d0[i] = b0 * 8;
  }
  // Channel 1: white noise for hiss layer
  const d1 = buf.getChannelData(1);
  for (let i = 0; i < d1.length; i++) d1[i] = Math.random() * 2 - 1;

  // Whoosh layer: brown noise â†’ lowpass â†’ gain (warm rumble)
  const whooshSrc = AC.createBufferSource();
  whooshSrc.buffer = buf;
  whooshSrc.loop = true;
  whooshSrc.channelCount = 1;
  whooshSrc.channelCountMode = 'explicit';
  const whooshSplit = AC.createChannelSplitter(2);
  whooshSrc.connect(whooshSplit);

  whooshFilter = AC.createBiquadFilter();
  whooshFilter.type = 'lowpass';
  whooshFilter.frequency.value = 400;
  whooshFilter.Q.value = 0.7;

  whooshGain = AC.createGain();
  whooshGain.gain.value = 0;

  whooshSplit.connect(whooshFilter, 0);
  whooshFilter.connect(whooshGain);

  // Hiss layer: white noise â†’ bandpass (airy jet whoosh)
  hissFilter = AC.createBiquadFilter();
  hissFilter.type = 'bandpass';
  hissFilter.frequency.value = 2200;
  hissFilter.Q.value = 0.5;

  hissGain = AC.createGain();
  hissGain.gain.value = 0;

  whooshSplit.connect(hissFilter, 1);
  hissFilter.connect(hissGain);

  // Sub layer: gentle sine for body (not harsh sawtooth)
  subOsc = AC.createOscillator();
  subOsc.type = 'sine';
  subOsc.frequency.value = 75;

  subGain = AC.createGain();
  subGain.gain.value = 0;
  subOsc.connect(subGain);

  // Highpass to clean mud
  hpf = AC.createBiquadFilter();
  hpf.type = 'highpass';
  hpf.frequency.value = 50;

  // Master
  masterGain = AC.createGain();
  masterGain.gain.value = 0.40;

  whooshGain.connect(hpf);
  hissGain.connect(hpf);
  subGain.connect(hpf);
  hpf.connect(masterGain);
  masterGain.connect(AC.destination);

  // Start everything now â€” sound controlled purely by gains
  whooshSrc.start();
  subOsc.start();
}

const REL = 0.20;   // 200ms release â€” smooth fade

// Core: set gains (only call when AC is running)
function fireEngineSound() {
  engineTarget = 1;
  const t = AC.currentTime;
  whooshGain.gain.cancelScheduledValues(t);
  hissGain.gain.cancelScheduledValues(t);
  subGain.gain.cancelScheduledValues(t);
  // Punch: snap to peak
  whooshGain.gain.setValueAtTime(0.60, t);
  hissGain.gain.setValueAtTime(0.18, t);
  subGain.gain.setValueAtTime(0.14, t);
  whooshFilter.frequency.setValueAtTime(700, t);
  // Settle to sustain
  whooshFilter.frequency.setTargetAtTime(550, t + 0.03, 0.06);
  whooshGain.gain.setTargetAtTime(0.50, t + 0.03, 0.06);
  hissGain.gain.setTargetAtTime(0.12, t + 0.03, 0.06);
  subGain.gain.setTargetAtTime(0.10, t + 0.03, 0.06);
}

// Safe trigger: build engine on first gesture, then resume + play
function triggerEngine() {
  buildEngine();
  if (AC.state !== 'running') {
    AC.resume().then(fireEngineSound);
  } else {
    fireEngineSound();
  }
}

function engineOff() {
  if (!engineReady || !AC) return;
  engineTarget = 0;
  const t = AC.currentTime;
  whooshGain.gain.cancelScheduledValues(t);
  hissGain.gain.cancelScheduledValues(t);
  subGain.gain.cancelScheduledValues(t);
  whooshGain.gain.setTargetAtTime(0, t, REL);
  hissGain.gain.setTargetAtTime(0, t, REL);
  subGain.gain.setTargetAtTime(0, t, REL);
  whooshFilter.frequency.setTargetAtTime(300, t, REL);
}

// Stars
const stars = [];
for (let i = 0; i < 90; i++) {
  stars.push({
    x: Math.random() * 3000, y: Math.random() * 3000,
    r: Math.random() * 2 + 0.5,
    tw: Math.random() * 6.28, sp: Math.random() * 0.02 + 0.01,
    par: Math.random() * 0.3 + 0.1
  });
}

// 10 bodies â€” each at a fixed height in the world
const bodies = [
  {name:'Moon',    c:'#ddddaa', r:18},
  {name:'Mars',    c:'#cc4422', r:24},
  {name:'Jupiter', c:'#dd9944', r:48},
  {name:'Saturn',  c:'#ddbb66', r:36, rings:true},
  {name:'Neptune', c:'#4466cc', r:28},
  {name:'Mercury', c:'#aaaaaa', r:16},
  {name:'Venus',   c:'#eecc66', r:22},
  {name:'Uranus',  c:'#77cccc', r:30},
  {name:'Pluto',   c:'#bbaa88', r:11},
  {name:'Sun',     c:'#ffdd44', r:52, glow:true},
];

// Rocket (moves on screen same as original)
let rocketY, rocketVY, boosting = false, boostTimer = 0;
rocketY = H * 0.55;
rocketVY = 0;
let boostAccum = 0, fallAccum = 0, heatNose = 0, heatTail = 0;

// World altitude â€” velocity-based so thrust/gravity feel real
let altitude = 0;
let worldVY = 0;  // world velocity (positive = climbing)

// Fixed world constants â€” same on every device
const SPACING = 1000;       // distance between planets in world units
const MAX_ALT = 10500;      // 10.5 * SPACING

// Particles
const particles = [];
function spawnFlame(x, y) {
  if (particles.length > 100) return;
  for (let i = 0; i < 4; i++) {
    particles.push({
      x: x + (Math.random()-0.5)*12*BU, y,
      vx: (Math.random()-0.5)*2, vy: Math.random()*4+2,
      life: 1, size: (Math.random()*6+3)*BU,
      color: Math.random()>0.5 ? '#ff6600' : '#ffcc00'
    });
  }
}

// Input â€” unified hold for touch, mouse, AND keyboard
let touchHold = false, keyHold = false, holding = false;
function updateHold() {
  holding = touchHold || keyHold;
  if (!holding) engineOff();
}
function boost() {
  boosting = true;
  boostTimer = 8;
  rocketVY = Math.max(rocketVY - 2.5, -4.5);
  triggerEngine();
}
function holdStart(e) { e.preventDefault(); touchHold = true; holding = true; boost(); }
function holdEnd(e) { touchHold = false; updateHold(); }
window.addEventListener('keydown', e => {
  e.preventDefault();
  if (!keyHold) { keyHold = true; holding = true; boost(); }
});
window.addEventListener('keyup', () => { keyHold = false; updateHold(); });
canvas.addEventListener('mousedown', holdStart);
canvas.addEventListener('mouseup', holdEnd);
canvas.addEventListener('mouseleave', holdEnd);
canvas.addEventListener('touchstart', holdStart, {passive:false});
canvas.addEventListener('touchend', holdEnd);
canvas.addEventListener('touchcancel', holdEnd);
// Block install-bar clicks from reaching game
document.getElementById('install-bar').addEventListener('mousedown', function(e){e.stopPropagation();});
document.getElementById('install-bar').addEventListener('touchstart', function(e){e.stopPropagation();}, {passive:false});

// World-to-screen: fixed scale so all devices progress at same speed
function wts(worldY) {
  const scale = H / 900;  // screen pixels per world unit
  return H * 0.6 - (worldY - altitude) * scale;
}

// Draw rocket
function drawRocket(x, y, sc, tilt, nHeat, tHeat) {
  ctx.save();
  ctx.translate(x, y); ctx.rotate(tilt); ctx.scale(sc, sc);
  // Body
  ctx.beginPath();
  ctx.moveTo(0,-50); ctx.bezierCurveTo(-15,-35,-18,10,-18,30);
  ctx.lineTo(18,30); ctx.bezierCurveTo(18,10,15,-35,0,-50); ctx.closePath();
  const bg = ctx.createLinearGradient(-18,-50,18,30);
  bg.addColorStop(0,'#fff'); bg.addColorStop(0.5,'#e8e8e8'); bg.addColorStop(1,'#ccc');
  ctx.fillStyle = bg; ctx.fill();
  ctx.strokeStyle = '#999'; ctx.lineWidth = 1.5; ctx.stroke();
  // Nose cone
  ctx.beginPath();
  ctx.moveTo(0,-50); ctx.bezierCurveTo(-8,-42,-12,-30,-14,-22);
  ctx.lineTo(14,-22); ctx.bezierCurveTo(12,-30,8,-42,0,-50);
  ctx.closePath(); ctx.fillStyle = '#ff3344'; ctx.fill();
  // Nose heat glow (sustained boost â€” going up)
  if (nHeat > 0.01) {
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(0,-50); ctx.bezierCurveTo(-8,-42,-12,-30,-14,-22);
    ctx.lineTo(14,-22); ctx.bezierCurveTo(12,-30,8,-42,0,-50);
    ctx.closePath(); ctx.clip();
    const hg = ctx.createRadialGradient(0, -48, 1, 0, -35, 28);
    hg.addColorStop(0, `rgba(255,255,200,${nHeat * 0.95})`);
    hg.addColorStop(0.35, `rgba(255,180,50,${nHeat * 0.75})`);
    hg.addColorStop(0.7, `rgba(255,80,20,${nHeat * 0.4})`);
    hg.addColorStop(1, 'rgba(200,30,10,0)');
    ctx.fillStyle = hg;
    ctx.fillRect(-16, -52, 32, 34);
    ctx.restore();
    // Outer halo
    ctx.save();
    ctx.globalAlpha = nHeat * 0.5;
    const og = ctx.createRadialGradient(0, -50, 0, 0, -42, 24);
    og.addColorStop(0, '#ffee88');
    og.addColorStop(0.4, '#ff8833');
    og.addColorStop(1, 'rgba(255,60,20,0)');
    ctx.fillStyle = og;
    ctx.beginPath(); ctx.arc(0, -42, 24, 0, 6.28); ctx.fill();
    ctx.globalAlpha = 1;
    ctx.restore();
  }
  // Window
  ctx.beginPath(); ctx.arc(0,-5,9,0,6.28);
  ctx.fillStyle = '#55ccff'; ctx.fill();
  ctx.beginPath(); ctx.arc(-2,-7,4,0,6.28);
  ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.fill();
  // Fins
  ctx.fillStyle = '#ff3344';
  ctx.beginPath(); ctx.moveTo(-18,20); ctx.lineTo(-32,38); ctx.lineTo(-18,30); ctx.fill();
  ctx.beginPath(); ctx.moveTo(18,20); ctx.lineTo(32,38); ctx.lineTo(18,30); ctx.fill();
  // Band
  ctx.beginPath(); ctx.moveTo(-16,10); ctx.lineTo(16,10); ctx.lineTo(17,16); ctx.lineTo(-17,16);
  ctx.closePath(); ctx.fillStyle = '#ff6600'; ctx.fill();
  // Tail heat glow (sustained free fall â€” re-entry)
  if (tHeat > 0.01) {
    // Glow on bottom of rocket body + fins
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(-32,38); ctx.lineTo(-18,20); ctx.lineTo(-18,30);
    ctx.lineTo(18,30); ctx.lineTo(18,20); ctx.lineTo(32,38);
    ctx.closePath(); ctx.clip();
    const tg = ctx.createRadialGradient(0, 34, 2, 0, 30, 30);
    tg.addColorStop(0, `rgba(255,255,200,${tHeat * 0.9})`);
    tg.addColorStop(0.3, `rgba(255,160,40,${tHeat * 0.7})`);
    tg.addColorStop(0.7, `rgba(255,60,10,${tHeat * 0.35})`);
    tg.addColorStop(1, 'rgba(200,30,10,0)');
    ctx.fillStyle = tg;
    ctx.fillRect(-34, 16, 68, 26);
    ctx.restore();
    // Outer tail halo
    ctx.save();
    ctx.globalAlpha = tHeat * 0.45;
    const th = ctx.createRadialGradient(0, 36, 0, 0, 34, 28);
    th.addColorStop(0, '#ffee88');
    th.addColorStop(0.4, '#ff8833');
    th.addColorStop(1, 'rgba(255,60,20,0)');
    ctx.fillStyle = th;
    ctx.beginPath(); ctx.arc(0, 34, 28, 0, 6.28); ctx.fill();
    ctx.globalAlpha = 1;
    ctx.restore();
  }
  ctx.restore();
}

function lighten(hex, n) {
  let r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
  return `rgb(${Math.min(255,r+n)},${Math.min(255,g+n)},${Math.min(255,b+n)})`;
}

// Main loop
let lastTime = 0, frameCount = 0;

function update(time) {
  const dt = Math.min((time - lastTime) / 16.67, 3);
  lastTime = time;
  frameCount++;

  // Hold-to-fire: keep boosting while touch/mouse is held
  if (holding) {
    boosting = true;
    boostTimer = 4;
    rocketVY = Math.max(rocketVY - 0.35 * dt, -4.5);
  }

  // Turn off engine sound when boost ends naturally (keyboard taps)
  if (!boosting && !holding && engineTarget === 1) engineOff();

  // Rocket on-screen physics
  if (boostTimer > 0) {
    boostTimer -= dt;
    rocketVY -= 0.1 * dt;
    spawnFlame(W/2, rocketY + 30*BU);
  } else boosting = false;

  rocketVY += 0.22 * dt;
  rocketVY *= (rocketVY > 0) ? 0.993 : 0.985;
  rocketVY = Math.max(-4.5, Math.min(rocketVY, 4.5));

  // Screen movement â€” clamped to safe bounds
  const pad = 120 * BU;
  const limitTop = pad;
  const limitBot = H - pad;
  rocketY += rocketVY * dt;
  if (rocketY < limitTop) { rocketY = limitTop; if (rocketVY < 0) rocketVY = 0; }
  if (rocketY > limitBot) { rocketY = limitBot; if (rocketVY > 0) rocketVY = 0; }

  // World velocity physics â€” screen-independent
  if (boosting) worldVY += 0.22 * dt;   // thrust builds speed gradually
  const grav = worldVY >= 0 ? 0.05 : 0.18;  // stronger pull when falling
  worldVY -= grav * dt;
  worldVY = Math.max(-6.5, Math.min(worldVY, 6.0));
  altitude += worldVY * dt;
  if (altitude <= 0) { altitude = 0; if (worldVY < 0) worldVY = 0; }
  if (altitude > MAX_ALT) altitude = MAX_ALT;

  // Heat glow â€” nose heats going up, tail heats falling down
  const HEAT_DELAY = 120;  // ~2 seconds at 60fps
  const HEAT_RAMP = 120;   // ~2 more seconds to full glow
  if (boosting) boostAccum += dt; else boostAccum *= 0.92;
  if (!boosting && rocketVY > 1.2 && altitude > SPACING * 0.5) fallAccum += dt; else fallAccum *= 0.92;
  const noseTarget = (boostAccum > HEAT_DELAY)
    ? Math.min(1, (boostAccum - HEAT_DELAY) / HEAT_RAMP) : 0;
  const tailTarget = (fallAccum > HEAT_DELAY)
    ? Math.min(1, (fallAccum - HEAT_DELAY) / HEAT_RAMP) : 0;
  heatNose += (noseTarget - heatNose) * 0.06 * dt;
  heatTail += (tailTarget - heatTail) * 0.06 * dt;
  if (heatNose < 0.005) heatNose = 0;
  if (heatTail < 0.005) heatTail = 0;

  // === DRAW ===
  ctx.fillStyle = '#080822';
  ctx.fillRect(0, 0, W, H);

  // Stars (parallax with altitude)
  for (const s of stars) {
    s.tw += s.sp;
    const a = 0.3 + Math.sin(s.tw) * 0.35;
    const sx = s.x % W;
    const sy = ((s.y + altitude * s.par) % H + H) % H;
    ctx.beginPath(); ctx.arc(sx, sy, s.r, 0, 6.28);
    ctx.fillStyle = `rgba(255,255,240,${a})`; ctx.fill();
  }

  // Earth (big curved surface at world height 0)
  const earthSY = wts(0);
  if (earthSY < H + 50) {
    const eR = W * 3;
    // Atmosphere glow
    ctx.beginPath(); ctx.arc(W/2, earthSY + eR, eR + 6, 0, 6.28);
    ctx.strokeStyle = 'rgba(100,180,255,0.3)'; ctx.lineWidth = 6; ctx.stroke();
    // Earth body
    ctx.beginPath(); ctx.arc(W/2, earthSY + eR, eR, 0, 6.28);
    const eg = ctx.createRadialGradient(W/2 - eR*0.2, earthSY + eR*0.3, eR*0.1, W/2, earthSY + eR, eR);
    eg.addColorStop(0, '#4488dd');
    eg.addColorStop(0.3, '#33aa55');
    eg.addColorStop(0.6, '#2288cc');
    eg.addColorStop(1, '#0a2244');
    ctx.fillStyle = eg; ctx.fill();
    // "Earth" label
    if (earthSY > H * 0.5) {
      ctx.font = `bold ${Math.max(14, 20*BU)}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      ctx.fillText('Earth', W/2, earthSY - 8*BU);
    }
  }

  // Big background numbers â€” centered, transparent, Star Trek credits style
  const bigNumF = Math.max(200, Math.min(520, W * 0.7));
  const bigNameF = Math.max(40, Math.min(100, W * 0.14));

  for (let i = 0; i < 10; i++) {
    const wy = (i + 1) * SPACING;
    const sy = wts(wy);
    if (sy < -200 || sy > H + 200) continue;
    // Number
    ctx.font = `bold ${bigNumF}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(255,255,255,0.07)';
    ctx.fillText(String(i + 1), W / 2, sy + bigNumF * 0.35);
    // Planet name
    ctx.font = `bold ${bigNameF}px sans-serif`;
    ctx.fillStyle = 'rgba(255,255,255,0.09)';
    ctx.fillText(bodies[i].name, W / 2, sy + bigNumF * 0.35 + bigNameF * 1.2);
  }

  // 10 planets at fixed world heights
  const nameF = Math.max(14, Math.min(28, W * 0.045));

  for (let i = 0; i < 10; i++) {
    const wy = (i + 1) * SPACING;
    const sy = wts(wy);
    if (sy < -100 || sy > H + 100) continue;

    const px = (i % 2 === 0) ? W * 0.22 : W * 0.78;
    const b = bodies[i];
    const r = b.r * BU;

    // Sun glow
    if (b.glow) {
      const gg = ctx.createRadialGradient(px, sy, r*0.5, px, sy, r*2.5);
      gg.addColorStop(0, 'rgba(255,220,60,0.35)');
      gg.addColorStop(1, 'rgba(255,220,60,0)');
      ctx.fillStyle = gg;
      ctx.fillRect(px-r*2.5, sy-r*2.5, r*5, r*5);
    }

    // Planet body
    ctx.beginPath(); ctx.arc(px, sy, r, 0, 6.28);
    const pg = ctx.createRadialGradient(px-r*0.3, sy-r*0.3, r*0.1, px, sy, r);
    pg.addColorStop(0, lighten(b.c, 50)); pg.addColorStop(1, b.c);
    ctx.fillStyle = pg; ctx.fill();

    // Saturn rings
    if (b.rings) {
      ctx.beginPath(); ctx.ellipse(px, sy, r*2, r*0.4, -0.25, 0, 6.28);
      ctx.strokeStyle = '#ccbb77'; ctx.lineWidth = r*0.22; ctx.stroke();
    }
    // Jupiter bands
    if (b.name === 'Jupiter') {
      ctx.save(); ctx.beginPath(); ctx.arc(px, sy, r, 0, 6.28); ctx.clip();
      ['#dd9944','#cc8833','#eebb55','#dd9944','#bb7733'].forEach((c,j) => {
        ctx.fillStyle = c;
        ctx.fillRect(px-r, sy-r+j*(2*r/5), 2*r, 2*r/5);
      });
      ctx.beginPath(); ctx.ellipse(px+r*0.3, sy+r*0.15, r*0.2, r*0.12, 0.2, 0, 6.28);
      ctx.fillStyle = '#cc4433'; ctx.fill();
      ctx.restore();
    }
    // Moon craters
    if (b.name === 'Moon') {
      ctx.beginPath(); ctx.arc(px-r*0.3, sy-r*0.2, r*0.17, 0, 6.28);
      ctx.fillStyle = 'rgba(150,150,120,0.4)'; ctx.fill();
      ctx.beginPath(); ctx.arc(px+r*0.2, sy+r*0.3, r*0.2, 0, 6.28);
      ctx.fillStyle = 'rgba(150,150,120,0.35)'; ctx.fill();
    }
    // Mars ice cap
    if (b.name === 'Mars') {
      ctx.beginPath(); ctx.arc(px, sy-r*0.65, r*0.35, 0, 6.28);
      ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.fill();
    }

    // Name (below planet)
    ctx.font = `bold ${nameF}px sans-serif`;
    ctx.fillStyle = b.c;
    ctx.fillText(b.name, px, sy + r + nameF + 4*BU);
  }

  // Particles
  for (let i = particles.length-1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx*dt; p.y += p.vy*dt;
    p.life -= 0.04*dt;
    if (p.life <= 0) { particles.splice(i,1); continue; }
    ctx.globalAlpha = p.life;
    ctx.beginPath(); ctx.arc(p.x, p.y, p.size*p.life, 0, 6.28);
    ctx.fillStyle = p.color; ctx.fill();
    ctx.globalAlpha = 1;
  }

  // Rocket â€” no wobble on ground, fades in with altitude
  const wobbleMix = Math.min(1, altitude / (SPACING * 0.3));
  const wobble = wobbleMix * (Math.sin(frameCount*0.03)*0.05 + rocketVY*0.015);
  drawRocket(W/2, rocketY, BU, wobble, heatNose, heatTail);

  // Hint
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.font = `${Math.max(12, 14*BU)}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.fillText('ontouchstart' in window ? 'Tap!' : 'Press any key or click!', W/2, H - 14);

  requestAnimationFrame(update);
}

requestAnimationFrame(update);

if ('serviceWorker' in navigator) navigator.serviceWorker.register('sw.js');

// Install prompt
(function() {
  const bar = document.getElementById('install-bar');
  const btn = document.getElementById('install-btn');
  const msg = document.getElementById('install-msg');
  const dismiss = document.getElementById('dismiss-btn');
  let deferredPrompt = null;

  // Don't show if already installed as PWA
  if (window.matchMedia('(display-mode: standalone)').matches) return;
  if (navigator.standalone) return; // iOS standalone
  if (sessionStorage.getItem('install-dismissed')) return;

  // Chrome/Edge: capture the beforeinstallprompt event
  window.addEventListener('beforeinstallprompt', function(e) {
    e.preventDefault();
    deferredPrompt = e;
    msg.textContent = 'Install Rocket! on your device';
    bar.style.display = 'flex';
  });

  // iOS Safari detection â€” no beforeinstallprompt, show manual hint
  var isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
  if (isIOS && !navigator.standalone) {
    setTimeout(function() {
      if (deferredPrompt) return; // Chrome on iOS won't fire, but just in case
      msg.innerHTML = 'Tap <strong>Share</strong> then <strong>Add to Home Screen</strong>';
      btn.style.display = 'none';
      bar.style.display = 'flex';
    }, 1500);
  }

  btn.addEventListener('click', function(e) {
    e.stopPropagation();
    if (!deferredPrompt) return;
    deferredPrompt.prompt();
    deferredPrompt.userChoice.then(function() {
      deferredPrompt = null;
      bar.style.display = 'none';
    });
  });

  dismiss.addEventListener('click', function(e) {
    e.stopPropagation();
    bar.style.display = 'none';
    sessionStorage.setItem('install-dismissed', '1');
  });

  // Hide after successful install
  window.addEventListener('appinstalled', function() {
    bar.style.display = 'none';
  });
})();
</script>
</body>
</html>
