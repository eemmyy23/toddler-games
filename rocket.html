<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Rocket! ðŸš€</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;touch-action:none;-webkit-user-select:none;user-select:none;background:#080822}
canvas{display:block;width:100%;height:100%}
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H, BU;
function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  BU = Math.min(W, H) / 500;
  if (BU < 0.7) BU = 0.7;
}
resize();
window.addEventListener('resize', resize);

// Audio â€” warm rocket whoosh engine
const AC = new (window.AudioContext || window.webkitAudioContext)();

// Pre-warm: start context + sources on very first interaction (before game input)
let engineReady = false;
let whooshGain, hissGain, subGain, masterGain;
let whooshFilter, hissFilter, hpf;
let subOsc;
let engineTarget = 0;

function buildEngine() {
  if (engineReady) return;
  engineReady = true;

  // Noise buffer (2 sec loop)
  const buf = AC.createBuffer(2, AC.sampleRate * 2, AC.sampleRate);
  // Channel 0: brownish noise (warmer, less harsh than white)
  const d0 = buf.getChannelData(0);
  let b0 = 0;
  for (let i = 0; i < d0.length; i++) {
    b0 = (b0 + (Math.random() * 2 - 1) * 0.06) * 0.98;
    d0[i] = b0 * 8;
  }
  // Channel 1: white noise for hiss layer
  const d1 = buf.getChannelData(1);
  for (let i = 0; i < d1.length; i++) d1[i] = Math.random() * 2 - 1;

  // Whoosh layer: brown noise â†’ lowpass â†’ gain (warm rumble)
  const whooshSrc = AC.createBufferSource();
  whooshSrc.buffer = buf;
  whooshSrc.loop = true;
  whooshSrc.channelCount = 1;
  whooshSrc.channelCountMode = 'explicit';
  const whooshSplit = AC.createChannelSplitter(2);
  whooshSrc.connect(whooshSplit);

  whooshFilter = AC.createBiquadFilter();
  whooshFilter.type = 'lowpass';
  whooshFilter.frequency.value = 400;
  whooshFilter.Q.value = 0.7;

  whooshGain = AC.createGain();
  whooshGain.gain.value = 0;

  whooshSplit.connect(whooshFilter, 0);
  whooshFilter.connect(whooshGain);

  // Hiss layer: white noise â†’ bandpass (airy jet whoosh)
  hissFilter = AC.createBiquadFilter();
  hissFilter.type = 'bandpass';
  hissFilter.frequency.value = 2200;
  hissFilter.Q.value = 0.5;

  hissGain = AC.createGain();
  hissGain.gain.value = 0;

  whooshSplit.connect(hissFilter, 1);
  hissFilter.connect(hissGain);

  // Sub layer: gentle sine for body (not harsh sawtooth)
  subOsc = AC.createOscillator();
  subOsc.type = 'sine';
  subOsc.frequency.value = 75;

  subGain = AC.createGain();
  subGain.gain.value = 0;
  subOsc.connect(subGain);

  // Highpass to clean mud
  hpf = AC.createBiquadFilter();
  hpf.type = 'highpass';
  hpf.frequency.value = 50;

  // Master
  masterGain = AC.createGain();
  masterGain.gain.value = 0.40;

  whooshGain.connect(hpf);
  hissGain.connect(hpf);
  subGain.connect(hpf);
  hpf.connect(masterGain);
  masterGain.connect(AC.destination);

  // Start everything now â€” sound controlled purely by gains
  whooshSrc.start();
  subOsc.start();
}

const REL = 0.20;   // 200ms release â€” smooth fade

// Core: set gains (only call when AC is running)
function fireEngineSound() {
  engineTarget = 1;
  const t = AC.currentTime;
  whooshGain.gain.cancelScheduledValues(t);
  hissGain.gain.cancelScheduledValues(t);
  subGain.gain.cancelScheduledValues(t);
  // Punch: snap to peak
  whooshGain.gain.setValueAtTime(0.60, t);
  hissGain.gain.setValueAtTime(0.18, t);
  subGain.gain.setValueAtTime(0.14, t);
  whooshFilter.frequency.setValueAtTime(700, t);
  // Settle to sustain
  whooshFilter.frequency.setTargetAtTime(550, t + 0.03, 0.06);
  whooshGain.gain.setTargetAtTime(0.50, t + 0.03, 0.06);
  hissGain.gain.setTargetAtTime(0.12, t + 0.03, 0.06);
  subGain.gain.setTargetAtTime(0.10, t + 0.03, 0.06);
}

// Safe trigger: handles first-tap async resume
function triggerEngine() {
  buildEngine();
  if (AC.state !== 'running') {
    AC.resume().then(fireEngineSound);
  } else {
    fireEngineSound();
  }
}

function engineOff() {
  if (!engineReady) return;
  engineTarget = 0;
  const t = AC.currentTime;
  whooshGain.gain.cancelScheduledValues(t);
  hissGain.gain.cancelScheduledValues(t);
  subGain.gain.cancelScheduledValues(t);
  whooshGain.gain.setTargetAtTime(0, t, REL);
  hissGain.gain.setTargetAtTime(0, t, REL);
  subGain.gain.setTargetAtTime(0, t, REL);
  whooshFilter.frequency.setTargetAtTime(300, t, REL);
}

// Stars
const stars = [];
for (let i = 0; i < 90; i++) {
  stars.push({
    x: Math.random() * 3000, y: Math.random() * 3000,
    r: Math.random() * 2 + 0.5,
    tw: Math.random() * 6.28, sp: Math.random() * 0.02 + 0.01,
    par: Math.random() * 0.3 + 0.1
  });
}

// 10 bodies â€” each at a fixed height in the world
const bodies = [
  {name:'Moon',    c:'#ddddaa', r:18},
  {name:'Mars',    c:'#cc4422', r:24},
  {name:'Jupiter', c:'#dd9944', r:48},
  {name:'Saturn',  c:'#ddbb66', r:36, rings:true},
  {name:'Neptune', c:'#4466cc', r:28},
  {name:'Mercury', c:'#aaaaaa', r:16},
  {name:'Venus',   c:'#eecc66', r:22},
  {name:'Uranus',  c:'#77cccc', r:30},
  {name:'Pluto',   c:'#bbaa88', r:11},
  {name:'Sun',     c:'#ffdd44', r:52, glow:true},
];

// Rocket (moves on screen same as original)
let rocketY, rocketVY, boosting = false, boostTimer = 0;
rocketY = H * 0.55;
rocketVY = 0;
let boostAccum = 0, fallAccum = 0, heatGlow = 0;

// World altitude â€” fire pushes up, gravity pulls back to Earth
let altitude = 0;

// Particles
const particles = [];
function spawnFlame(x, y) {
  if (particles.length > 100) return;
  for (let i = 0; i < 4; i++) {
    particles.push({
      x: x + (Math.random()-0.5)*12*BU, y,
      vx: (Math.random()-0.5)*2, vy: Math.random()*4+2,
      life: 1, size: (Math.random()*6+3)*BU,
      color: Math.random()>0.5 ? '#ff6600' : '#ffcc00'
    });
  }
}

// Input
let holding = false;
function boost() {
  boosting = true;
  boostTimer = 8;
  rocketVY = Math.max(rocketVY - 2.5, -4.5);
  triggerEngine();
}
function holdStart(e) { e.preventDefault(); holding = true; boost(); }
function holdEnd(e) { holding = false; engineOff(); }
window.addEventListener('keydown', e => { e.preventDefault(); boost(); });
window.addEventListener('keyup', () => { if (!holding) engineOff(); });
canvas.addEventListener('mousedown', holdStart);
canvas.addEventListener('mouseup', holdEnd);
canvas.addEventListener('mouseleave', holdEnd);
canvas.addEventListener('touchstart', holdStart, {passive:false});
canvas.addEventListener('touchend', holdEnd);
canvas.addEventListener('touchcancel', holdEnd);

// World-to-screen: rocket at H*0.45, world scrolls around it
function wts(worldY) {
  return H * 0.6 - (worldY - altitude);
}

// Draw rocket
function drawRocket(x, y, sc, tilt, heat) {
  ctx.save();
  ctx.translate(x, y); ctx.rotate(tilt); ctx.scale(sc, sc);
  // Body
  ctx.beginPath();
  ctx.moveTo(0,-50); ctx.bezierCurveTo(-15,-35,-18,10,-18,30);
  ctx.lineTo(18,30); ctx.bezierCurveTo(18,10,15,-35,0,-50); ctx.closePath();
  const bg = ctx.createLinearGradient(-18,-50,18,30);
  bg.addColorStop(0,'#fff'); bg.addColorStop(0.5,'#e8e8e8'); bg.addColorStop(1,'#ccc');
  ctx.fillStyle = bg; ctx.fill();
  ctx.strokeStyle = '#999'; ctx.lineWidth = 1.5; ctx.stroke();
  // Nose cone
  ctx.beginPath();
  ctx.moveTo(0,-50); ctx.bezierCurveTo(-8,-42,-12,-30,-14,-22);
  ctx.lineTo(14,-22); ctx.bezierCurveTo(12,-30,8,-42,0,-50);
  ctx.closePath(); ctx.fillStyle = '#ff3344'; ctx.fill();
  // Heat glow on nose cone (re-entry / friction heating)
  if (heat > 0.01) {
    ctx.save();
    // Clip to nose cone shape
    ctx.beginPath();
    ctx.moveTo(0,-50); ctx.bezierCurveTo(-8,-42,-12,-30,-14,-22);
    ctx.lineTo(14,-22); ctx.bezierCurveTo(12,-30,8,-42,0,-50);
    ctx.closePath(); ctx.clip();
    // Hot gradient: tip is brightest
    const hg = ctx.createRadialGradient(0, -48, 2, 0, -35, 28);
    hg.addColorStop(0, `rgba(255,255,200,${heat * 0.9})`);
    hg.addColorStop(0.3, `rgba(255,180,50,${heat * 0.7})`);
    hg.addColorStop(0.7, `rgba(255,80,20,${heat * 0.4})`);
    hg.addColorStop(1, `rgba(200,30,10,0)`);
    ctx.fillStyle = hg;
    ctx.fillRect(-16, -52, 32, 34);
    ctx.restore();
    // Outer glow halo around nose tip
    ctx.save();
    ctx.globalAlpha = heat * 0.35;
    const og = ctx.createRadialGradient(0, -50, 0, 0, -44, 20);
    og.addColorStop(0, '#ffee88');
    og.addColorStop(0.5, '#ff8833');
    og.addColorStop(1, 'rgba(255,60,20,0)');
    ctx.fillStyle = og;
    ctx.beginPath(); ctx.arc(0, -44, 20, 0, 6.28); ctx.fill();
    ctx.globalAlpha = 1;
    ctx.restore();
  }
  // Window
  ctx.beginPath(); ctx.arc(0,-5,9,0,6.28);
  ctx.fillStyle = '#55ccff'; ctx.fill();
  ctx.beginPath(); ctx.arc(-2,-7,4,0,6.28);
  ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.fill();
  // Fins
  ctx.fillStyle = '#ff3344';
  ctx.beginPath(); ctx.moveTo(-18,20); ctx.lineTo(-32,38); ctx.lineTo(-18,30); ctx.fill();
  ctx.beginPath(); ctx.moveTo(18,20); ctx.lineTo(32,38); ctx.lineTo(18,30); ctx.fill();
  // Band
  ctx.beginPath(); ctx.moveTo(-16,10); ctx.lineTo(16,10); ctx.lineTo(17,16); ctx.lineTo(-17,16);
  ctx.closePath(); ctx.fillStyle = '#ff6600'; ctx.fill();
  ctx.restore();
}

function lighten(hex, n) {
  let r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
  return `rgb(${Math.min(255,r+n)},${Math.min(255,g+n)},${Math.min(255,b+n)})`;
}

// Main loop
let lastTime = 0, frameCount = 0;

function update(time) {
  const dt = Math.min((time - lastTime) / 16.67, 3);
  lastTime = time;
  frameCount++;

  const SPACING = Math.max(350, H * 1.1);
  const MAX_ALT = 10.5 * SPACING;

  // Hold-to-fire: keep boosting while touch/mouse is held
  if (holding) {
    boosting = true;
    boostTimer = 4;
    rocketVY = Math.max(rocketVY - 0.35 * dt, -4.5);
  }

  // Turn off engine sound when boost ends naturally (keyboard taps)
  if (!boosting && !holding && engineTarget === 1) engineOff();

  // Rocket on-screen physics
  if (boostTimer > 0) {
    boostTimer -= dt;
    rocketVY -= 0.1 * dt;
    spawnFlame(W/2, rocketY + 30*BU);
  } else boosting = false;

  rocketVY += 0.22 * dt;
  rocketVY *= (rocketVY > 0) ? 0.993 : 0.985;
  rocketVY = Math.max(-4.5, Math.min(rocketVY, 4.5));

  // Progressive edge transfer â€” near edges, velocity smoothly
  // shifts from screen movement into world scroll (no walls)
  const pad = 120 * BU;                // rocket height + generous margin
  const limitTop = pad;                 // rocket center never above this
  const limitBot = H - pad;             // rocket center never below this
  const edgeTop = limitTop + H * 0.18;  // transfer fades in over 18% of screen
  const edgeBot = limitBot - H * 0.18;
  let transfer = 0;
  if (rocketVY < 0 && rocketY < edgeTop) {
    const t = (edgeTop - rocketY) / (edgeTop - limitTop);
    transfer = Math.min(1, t * t);
  } else if (rocketVY > 0 && rocketY > edgeBot) {
    const t = (rocketY - edgeBot) / (limitBot - edgeBot);
    transfer = Math.min(1, t * t);
  }
  rocketY += rocketVY * (1 - transfer * 0.95) * dt;
  altitude -= rocketVY * transfer * 0.9 * dt;
  rocketY = Math.max(limitTop, Math.min(rocketY, limitBot));

  // Base world scroll
  if (boosting) altitude += 2.5 * dt;
  altitude -= 0.25 * dt;
  if (altitude < 0) altitude = 0;
  if (altitude > MAX_ALT) altitude = MAX_ALT;

  // Heat glow â€” builds after 2s of sustained boost or free fall
  const HEAT_DELAY = 120;  // ~2 seconds at 60fps
  const HEAT_RAMP = 300;   // frames to reach full glow after delay
  if (boosting) { boostAccum += dt; fallAccum = 0; }
  else if (rocketVY > 1.5) { fallAccum += dt; boostAccum = 0; }
  else { boostAccum *= 0.95; fallAccum *= 0.95; }
  const activeAccum = Math.max(boostAccum, fallAccum);
  const heatTarget = (activeAccum > HEAT_DELAY)
    ? Math.min(1, (activeAccum - HEAT_DELAY) / HEAT_RAMP) : 0;
  heatGlow += (heatTarget - heatGlow) * 0.03 * dt;

  // === DRAW ===
  ctx.fillStyle = '#080822';
  ctx.fillRect(0, 0, W, H);

  // Stars (parallax with altitude)
  for (const s of stars) {
    s.tw += s.sp;
    const a = 0.3 + Math.sin(s.tw) * 0.35;
    const sx = s.x % W;
    const sy = ((s.y + altitude * s.par) % H + H) % H;
    ctx.beginPath(); ctx.arc(sx, sy, s.r, 0, 6.28);
    ctx.fillStyle = `rgba(255,255,240,${a})`; ctx.fill();
  }

  // Earth (big curved surface at world height 0)
  const earthSY = wts(0);
  if (earthSY < H + 50) {
    const eR = W * 3;
    // Atmosphere glow
    ctx.beginPath(); ctx.arc(W/2, earthSY + eR, eR + 6, 0, 6.28);
    ctx.strokeStyle = 'rgba(100,180,255,0.3)'; ctx.lineWidth = 6; ctx.stroke();
    // Earth body
    ctx.beginPath(); ctx.arc(W/2, earthSY + eR, eR, 0, 6.28);
    const eg = ctx.createRadialGradient(W/2 - eR*0.2, earthSY + eR*0.3, eR*0.1, W/2, earthSY + eR, eR);
    eg.addColorStop(0, '#4488dd');
    eg.addColorStop(0.3, '#33aa55');
    eg.addColorStop(0.6, '#2288cc');
    eg.addColorStop(1, '#0a2244');
    ctx.fillStyle = eg; ctx.fill();
    // "Earth" label
    if (earthSY > H * 0.5) {
      ctx.font = `bold ${Math.max(14, 20*BU)}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      ctx.fillText('Earth', W/2, earthSY - 8*BU);
    }
  }

  // Big background numbers â€” centered, transparent, Star Trek credits style
  const bigNumF = Math.max(200, Math.min(520, W * 0.7));
  const bigNameF = Math.max(40, Math.min(100, W * 0.14));

  for (let i = 0; i < 10; i++) {
    const wy = (i + 1) * SPACING;
    const sy = wts(wy);
    if (sy < -200 || sy > H + 200) continue;
    // Number
    ctx.font = `bold ${bigNumF}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(255,255,255,0.07)';
    ctx.fillText(String(i + 1), W / 2, sy + bigNumF * 0.35);
    // Planet name
    ctx.font = `bold ${bigNameF}px sans-serif`;
    ctx.fillStyle = 'rgba(255,255,255,0.09)';
    ctx.fillText(bodies[i].name, W / 2, sy + bigNumF * 0.35 + bigNameF * 1.2);
  }

  // 10 planets at fixed world heights
  const nameF = Math.max(14, Math.min(28, W * 0.045));

  for (let i = 0; i < 10; i++) {
    const wy = (i + 1) * SPACING;
    const sy = wts(wy);
    if (sy < -100 || sy > H + 100) continue;

    const px = (i % 2 === 0) ? W * 0.22 : W * 0.78;
    const b = bodies[i];
    const r = b.r * BU;

    // Sun glow
    if (b.glow) {
      const gg = ctx.createRadialGradient(px, sy, r*0.5, px, sy, r*2.5);
      gg.addColorStop(0, 'rgba(255,220,60,0.35)');
      gg.addColorStop(1, 'rgba(255,220,60,0)');
      ctx.fillStyle = gg;
      ctx.fillRect(px-r*2.5, sy-r*2.5, r*5, r*5);
    }

    // Planet body
    ctx.beginPath(); ctx.arc(px, sy, r, 0, 6.28);
    const pg = ctx.createRadialGradient(px-r*0.3, sy-r*0.3, r*0.1, px, sy, r);
    pg.addColorStop(0, lighten(b.c, 50)); pg.addColorStop(1, b.c);
    ctx.fillStyle = pg; ctx.fill();

    // Saturn rings
    if (b.rings) {
      ctx.beginPath(); ctx.ellipse(px, sy, r*2, r*0.4, -0.25, 0, 6.28);
      ctx.strokeStyle = '#ccbb77'; ctx.lineWidth = r*0.22; ctx.stroke();
    }
    // Jupiter bands
    if (b.name === 'Jupiter') {
      ctx.save(); ctx.beginPath(); ctx.arc(px, sy, r, 0, 6.28); ctx.clip();
      ['#dd9944','#cc8833','#eebb55','#dd9944','#bb7733'].forEach((c,j) => {
        ctx.fillStyle = c;
        ctx.fillRect(px-r, sy-r+j*(2*r/5), 2*r, 2*r/5);
      });
      ctx.beginPath(); ctx.ellipse(px+r*0.3, sy+r*0.15, r*0.2, r*0.12, 0.2, 0, 6.28);
      ctx.fillStyle = '#cc4433'; ctx.fill();
      ctx.restore();
    }
    // Moon craters
    if (b.name === 'Moon') {
      ctx.beginPath(); ctx.arc(px-r*0.3, sy-r*0.2, r*0.17, 0, 6.28);
      ctx.fillStyle = 'rgba(150,150,120,0.4)'; ctx.fill();
      ctx.beginPath(); ctx.arc(px+r*0.2, sy+r*0.3, r*0.2, 0, 6.28);
      ctx.fillStyle = 'rgba(150,150,120,0.35)'; ctx.fill();
    }
    // Mars ice cap
    if (b.name === 'Mars') {
      ctx.beginPath(); ctx.arc(px, sy-r*0.65, r*0.35, 0, 6.28);
      ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.fill();
    }

    // Name (below planet)
    ctx.font = `bold ${nameF}px sans-serif`;
    ctx.fillStyle = b.c;
    ctx.fillText(b.name, px, sy + r + nameF + 4*BU);
  }

  // Particles
  for (let i = particles.length-1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx*dt; p.y += p.vy*dt;
    p.life -= 0.04*dt;
    if (p.life <= 0) { particles.splice(i,1); continue; }
    ctx.globalAlpha = p.life;
    ctx.beginPath(); ctx.arc(p.x, p.y, p.size*p.life, 0, 6.28);
    ctx.fillStyle = p.color; ctx.fill();
    ctx.globalAlpha = 1;
  }

  // Rocket
  const wobble = Math.sin(frameCount*0.03)*0.05 + rocketVY*0.015;
  if (boosting) {
    ctx.save(); ctx.shadowColor = '#ff8800'; ctx.shadowBlur = 25*BU;
    drawRocket(W/2, rocketY, BU, wobble, heatGlow);
    ctx.restore();
  } else {
    drawRocket(W/2, rocketY, BU, wobble, heatGlow);
  }

  // Hint
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.font = `${Math.max(12, 14*BU)}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.fillText('ontouchstart' in window ? 'Tap!' : 'Press any key or click!', W/2, H - 14);

  requestAnimationFrame(update);
}

requestAnimationFrame(update);
</script>
</body>
</html>
